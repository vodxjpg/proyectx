"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/rou3";
exports.ids = ["vendor-chunks/rou3"];
exports.modules = {

/***/ "(rsc)/./node_modules/rou3/dist/index.mjs":
/*!******************************************!*\
  !*** ./node_modules/rou3/dist/index.mjs ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addRoute: () => (/* binding */ addRoute),\n/* harmony export */   createRouter: () => (/* binding */ createRouter),\n/* harmony export */   findAllRoutes: () => (/* binding */ findAllRoutes),\n/* harmony export */   findRoute: () => (/* binding */ findRoute),\n/* harmony export */   removeRoute: () => (/* binding */ removeRoute)\n/* harmony export */ });\nconst EmptyObject = /* @__PURE__ */ (() => {\n  const C = function() {\n  };\n  C.prototype = /* @__PURE__ */ Object.create(null);\n  return C;\n})();\n\nfunction createRouter() {\n  const ctx = {\n    root: { key: \"\" },\n    static: new EmptyObject()\n  };\n  return ctx;\n}\n\nfunction splitPath(path) {\n  return path.split(\"/\").filter(Boolean);\n}\nfunction getMatchParams(segments, paramsMap) {\n  const params = new EmptyObject();\n  for (const [index, name] of paramsMap) {\n    const segment = index < 0 ? segments.slice(-1 * index).join(\"/\") : segments[index];\n    if (typeof name === \"string\") {\n      params[name] = segment;\n    } else {\n      const match = segment.match(name);\n      if (match) {\n        for (const key in match.groups) {\n          params[key] = match.groups[key];\n        }\n      }\n    }\n  }\n  return params;\n}\n\nfunction addRoute(ctx, method = \"\", path, data) {\n  const segments = splitPath(path);\n  let node = ctx.root;\n  let _unnamedParamIndex = 0;\n  const paramsMap = [];\n  for (let i = 0; i < segments.length; i++) {\n    const segment = segments[i];\n    if (segment.startsWith(\"**\")) {\n      if (!node.wildcard) {\n        node.wildcard = { key: \"**\" };\n      }\n      node = node.wildcard;\n      paramsMap.push([\n        -i,\n        segment.split(\":\")[1] || \"_\",\n        segment.length === 2\n      ]);\n      break;\n    }\n    if (segment === \"*\" || segment.includes(\":\")) {\n      if (!node.param) {\n        node.param = { key: \"*\" };\n      }\n      node = node.param;\n      const isOptional = segment === \"*\";\n      paramsMap.push([\n        i,\n        isOptional ? `_${_unnamedParamIndex++}` : _getParamMatcher(segment),\n        isOptional\n      ]);\n      continue;\n    }\n    const child = node.static?.[segment];\n    if (child) {\n      node = child;\n    } else {\n      const staticNode = { key: segment };\n      if (!node.static) {\n        node.static = new EmptyObject();\n      }\n      node.static[segment] = staticNode;\n      node = staticNode;\n    }\n  }\n  const hasParams = paramsMap.length > 0;\n  if (!node.methods) {\n    node.methods = new EmptyObject();\n  }\n  if (!node.methods[method]) {\n    node.methods[method] = [];\n  }\n  node.methods[method].push({\n    data: data || null,\n    paramsMap: hasParams ? paramsMap : void 0\n  });\n  if (!hasParams) {\n    ctx.static[path] = node;\n  }\n}\nfunction _getParamMatcher(segment) {\n  if (!segment.includes(\":\", 1)) {\n    return segment.slice(1);\n  }\n  const regex = segment.replace(/:(\\w+)/g, (_, id) => `(?<${id}>\\\\w+)`);\n  return new RegExp(`^${regex}$`);\n}\n\nfunction findRoute(ctx, method = \"\", path, opts) {\n  if (path[path.length - 1] === \"/\") {\n    path = path.slice(0, -1);\n  }\n  const staticNode = ctx.static[path];\n  if (staticNode && staticNode.methods) {\n    const staticMatch = staticNode.methods[method] || staticNode.methods[\"\"];\n    if (staticMatch !== void 0) {\n      return staticMatch[0];\n    }\n  }\n  const segments = splitPath(path);\n  const match = _lookupTree(ctx, ctx.root, method, segments, 0)?.[0];\n  if (match === void 0) {\n    return;\n  }\n  if (opts?.params === false) {\n    return match;\n  }\n  return {\n    data: match.data,\n    params: match.paramsMap ? getMatchParams(segments, match.paramsMap) : void 0\n  };\n}\nfunction _lookupTree(ctx, node, method, segments, index) {\n  if (index === segments.length) {\n    if (node.methods) {\n      const match = node.methods[method] || node.methods[\"\"];\n      if (match) {\n        return match;\n      }\n    }\n    if (node.param && node.param.methods) {\n      const match = node.param.methods[method] || node.param.methods[\"\"];\n      if (match) {\n        const pMap = match[0].paramsMap;\n        if (pMap?.[pMap?.length - 1]?.[2]) {\n          return match;\n        }\n      }\n    }\n    if (node.wildcard && node.wildcard.methods) {\n      const match = node.wildcard.methods[method] || node.wildcard.methods[\"\"];\n      if (match) {\n        const pMap = match[0].paramsMap;\n        if (pMap?.[pMap?.length - 1]?.[2]) {\n          return match;\n        }\n      }\n    }\n    return void 0;\n  }\n  const segment = segments[index];\n  if (node.static) {\n    const staticChild = node.static[segment];\n    if (staticChild) {\n      const match = _lookupTree(ctx, staticChild, method, segments, index + 1);\n      if (match) {\n        return match;\n      }\n    }\n  }\n  if (node.param) {\n    const match = _lookupTree(ctx, node.param, method, segments, index + 1);\n    if (match) {\n      return match;\n    }\n  }\n  if (node.wildcard && node.wildcard.methods) {\n    return node.wildcard.methods[method] || node.wildcard.methods[\"\"];\n  }\n  return;\n}\n\nfunction removeRoute(ctx, method, path) {\n  const segments = splitPath(path);\n  return _remove(ctx.root, method || \"\", segments, 0);\n}\nfunction _remove(node, method, segments, index) {\n  if (index === segments.length) {\n    if (node.methods && method in node.methods) {\n      delete node.methods[method];\n      if (Object.keys(node.methods).length === 0) {\n        node.methods = void 0;\n      }\n    }\n    return;\n  }\n  const segment = segments[index];\n  if (segment === \"*\") {\n    if (node.param) {\n      _remove(node.param, method, segments, index + 1);\n      if (_isEmptyNode(node.param)) {\n        node.param = void 0;\n      }\n    }\n    return;\n  }\n  if (segment === \"**\") {\n    if (node.wildcard) {\n      _remove(node.wildcard, method, segments, index + 1);\n      if (_isEmptyNode(node.wildcard)) {\n        node.wildcard = void 0;\n      }\n    }\n    return;\n  }\n  const childNode = node.static?.[segment];\n  if (childNode) {\n    _remove(childNode, method, segments, index + 1);\n    if (_isEmptyNode(childNode)) {\n      delete node.static[segment];\n      if (Object.keys(node.static).length === 0) {\n        node.static = void 0;\n      }\n    }\n  }\n}\nfunction _isEmptyNode(node) {\n  return node.methods === void 0 && node.static === void 0 && node.param === void 0 && node.wildcard === void 0;\n}\n\nfunction findAllRoutes(ctx, method = \"\", path, opts) {\n  if (path[path.length - 1] === \"/\") {\n    path = path.slice(0, -1);\n  }\n  const segments = splitPath(path);\n  const matches = _findAll(ctx, ctx.root, method, segments, 0);\n  if (opts?.params === false) {\n    return matches;\n  }\n  return matches.map((m) => {\n    return {\n      data: m.data,\n      params: m.paramsMap ? getMatchParams(segments, m.paramsMap) : void 0\n    };\n  });\n}\nfunction _findAll(ctx, node, method, segments, index, matches = []) {\n  const segment = segments[index];\n  if (node.wildcard && node.wildcard.methods) {\n    const match = node.wildcard.methods[method] || node.wildcard.methods[\"\"];\n    if (match) {\n      matches.push(...match);\n    }\n  }\n  if (node.param) {\n    _findAll(ctx, node.param, method, segments, index + 1, matches);\n    if (index === segments.length && node.param.methods) {\n      const match = node.param.methods[method] || node.param.methods[\"\"];\n      if (match) {\n        matches.push(...match);\n      }\n    }\n  }\n  const staticChild = node.static?.[segment];\n  if (staticChild) {\n    _findAll(ctx, staticChild, method, segments, index + 1, matches);\n  }\n  if (index === segments.length && node.methods) {\n    const match = node.methods[method] || node.methods[\"\"];\n    if (match) {\n      matches.push(...match);\n    }\n  }\n  return matches;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcm91My9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IscUJBQXFCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIscUJBQXFCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsR0FBRztBQUMvRCx3QkFBd0IsTUFBTTtBQUM5Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV5RSIsInNvdXJjZXMiOlsid2VicGFjazovL3RyYXBpZ3JhbS8uL25vZGVfbW9kdWxlcy9yb3UzL2Rpc3QvaW5kZXgubWpzPzgxOWUiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgRW1wdHlPYmplY3QgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IHtcbiAgY29uc3QgQyA9IGZ1bmN0aW9uKCkge1xuICB9O1xuICBDLnByb3RvdHlwZSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICByZXR1cm4gQztcbn0pKCk7XG5cbmZ1bmN0aW9uIGNyZWF0ZVJvdXRlcigpIHtcbiAgY29uc3QgY3R4ID0ge1xuICAgIHJvb3Q6IHsga2V5OiBcIlwiIH0sXG4gICAgc3RhdGljOiBuZXcgRW1wdHlPYmplY3QoKVxuICB9O1xuICByZXR1cm4gY3R4O1xufVxuXG5mdW5jdGlvbiBzcGxpdFBhdGgocGF0aCkge1xuICByZXR1cm4gcGF0aC5zcGxpdChcIi9cIikuZmlsdGVyKEJvb2xlYW4pO1xufVxuZnVuY3Rpb24gZ2V0TWF0Y2hQYXJhbXMoc2VnbWVudHMsIHBhcmFtc01hcCkge1xuICBjb25zdCBwYXJhbXMgPSBuZXcgRW1wdHlPYmplY3QoKTtcbiAgZm9yIChjb25zdCBbaW5kZXgsIG5hbWVdIG9mIHBhcmFtc01hcCkge1xuICAgIGNvbnN0IHNlZ21lbnQgPSBpbmRleCA8IDAgPyBzZWdtZW50cy5zbGljZSgtMSAqIGluZGV4KS5qb2luKFwiL1wiKSA6IHNlZ21lbnRzW2luZGV4XTtcbiAgICBpZiAodHlwZW9mIG5hbWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHBhcmFtc1tuYW1lXSA9IHNlZ21lbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG1hdGNoID0gc2VnbWVudC5tYXRjaChuYW1lKTtcbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBtYXRjaC5ncm91cHMpIHtcbiAgICAgICAgICBwYXJhbXNba2V5XSA9IG1hdGNoLmdyb3Vwc1trZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBwYXJhbXM7XG59XG5cbmZ1bmN0aW9uIGFkZFJvdXRlKGN0eCwgbWV0aG9kID0gXCJcIiwgcGF0aCwgZGF0YSkge1xuICBjb25zdCBzZWdtZW50cyA9IHNwbGl0UGF0aChwYXRoKTtcbiAgbGV0IG5vZGUgPSBjdHgucm9vdDtcbiAgbGV0IF91bm5hbWVkUGFyYW1JbmRleCA9IDA7XG4gIGNvbnN0IHBhcmFtc01hcCA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgc2VnbWVudCA9IHNlZ21lbnRzW2ldO1xuICAgIGlmIChzZWdtZW50LnN0YXJ0c1dpdGgoXCIqKlwiKSkge1xuICAgICAgaWYgKCFub2RlLndpbGRjYXJkKSB7XG4gICAgICAgIG5vZGUud2lsZGNhcmQgPSB7IGtleTogXCIqKlwiIH07XG4gICAgICB9XG4gICAgICBub2RlID0gbm9kZS53aWxkY2FyZDtcbiAgICAgIHBhcmFtc01hcC5wdXNoKFtcbiAgICAgICAgLWksXG4gICAgICAgIHNlZ21lbnQuc3BsaXQoXCI6XCIpWzFdIHx8IFwiX1wiLFxuICAgICAgICBzZWdtZW50Lmxlbmd0aCA9PT0gMlxuICAgICAgXSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKHNlZ21lbnQgPT09IFwiKlwiIHx8IHNlZ21lbnQuaW5jbHVkZXMoXCI6XCIpKSB7XG4gICAgICBpZiAoIW5vZGUucGFyYW0pIHtcbiAgICAgICAgbm9kZS5wYXJhbSA9IHsga2V5OiBcIipcIiB9O1xuICAgICAgfVxuICAgICAgbm9kZSA9IG5vZGUucGFyYW07XG4gICAgICBjb25zdCBpc09wdGlvbmFsID0gc2VnbWVudCA9PT0gXCIqXCI7XG4gICAgICBwYXJhbXNNYXAucHVzaChbXG4gICAgICAgIGksXG4gICAgICAgIGlzT3B0aW9uYWwgPyBgXyR7X3VubmFtZWRQYXJhbUluZGV4Kyt9YCA6IF9nZXRQYXJhbU1hdGNoZXIoc2VnbWVudCksXG4gICAgICAgIGlzT3B0aW9uYWxcbiAgICAgIF0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IGNoaWxkID0gbm9kZS5zdGF0aWM/LltzZWdtZW50XTtcbiAgICBpZiAoY2hpbGQpIHtcbiAgICAgIG5vZGUgPSBjaGlsZDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgc3RhdGljTm9kZSA9IHsga2V5OiBzZWdtZW50IH07XG4gICAgICBpZiAoIW5vZGUuc3RhdGljKSB7XG4gICAgICAgIG5vZGUuc3RhdGljID0gbmV3IEVtcHR5T2JqZWN0KCk7XG4gICAgICB9XG4gICAgICBub2RlLnN0YXRpY1tzZWdtZW50XSA9IHN0YXRpY05vZGU7XG4gICAgICBub2RlID0gc3RhdGljTm9kZTtcbiAgICB9XG4gIH1cbiAgY29uc3QgaGFzUGFyYW1zID0gcGFyYW1zTWFwLmxlbmd0aCA+IDA7XG4gIGlmICghbm9kZS5tZXRob2RzKSB7XG4gICAgbm9kZS5tZXRob2RzID0gbmV3IEVtcHR5T2JqZWN0KCk7XG4gIH1cbiAgaWYgKCFub2RlLm1ldGhvZHNbbWV0aG9kXSkge1xuICAgIG5vZGUubWV0aG9kc1ttZXRob2RdID0gW107XG4gIH1cbiAgbm9kZS5tZXRob2RzW21ldGhvZF0ucHVzaCh7XG4gICAgZGF0YTogZGF0YSB8fCBudWxsLFxuICAgIHBhcmFtc01hcDogaGFzUGFyYW1zID8gcGFyYW1zTWFwIDogdm9pZCAwXG4gIH0pO1xuICBpZiAoIWhhc1BhcmFtcykge1xuICAgIGN0eC5zdGF0aWNbcGF0aF0gPSBub2RlO1xuICB9XG59XG5mdW5jdGlvbiBfZ2V0UGFyYW1NYXRjaGVyKHNlZ21lbnQpIHtcbiAgaWYgKCFzZWdtZW50LmluY2x1ZGVzKFwiOlwiLCAxKSkge1xuICAgIHJldHVybiBzZWdtZW50LnNsaWNlKDEpO1xuICB9XG4gIGNvbnN0IHJlZ2V4ID0gc2VnbWVudC5yZXBsYWNlKC86KFxcdyspL2csIChfLCBpZCkgPT4gYCg/PCR7aWR9PlxcXFx3KylgKTtcbiAgcmV0dXJuIG5ldyBSZWdFeHAoYF4ke3JlZ2V4fSRgKTtcbn1cblxuZnVuY3Rpb24gZmluZFJvdXRlKGN0eCwgbWV0aG9kID0gXCJcIiwgcGF0aCwgb3B0cykge1xuICBpZiAocGF0aFtwYXRoLmxlbmd0aCAtIDFdID09PSBcIi9cIikge1xuICAgIHBhdGggPSBwYXRoLnNsaWNlKDAsIC0xKTtcbiAgfVxuICBjb25zdCBzdGF0aWNOb2RlID0gY3R4LnN0YXRpY1twYXRoXTtcbiAgaWYgKHN0YXRpY05vZGUgJiYgc3RhdGljTm9kZS5tZXRob2RzKSB7XG4gICAgY29uc3Qgc3RhdGljTWF0Y2ggPSBzdGF0aWNOb2RlLm1ldGhvZHNbbWV0aG9kXSB8fCBzdGF0aWNOb2RlLm1ldGhvZHNbXCJcIl07XG4gICAgaWYgKHN0YXRpY01hdGNoICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBzdGF0aWNNYXRjaFswXTtcbiAgICB9XG4gIH1cbiAgY29uc3Qgc2VnbWVudHMgPSBzcGxpdFBhdGgocGF0aCk7XG4gIGNvbnN0IG1hdGNoID0gX2xvb2t1cFRyZWUoY3R4LCBjdHgucm9vdCwgbWV0aG9kLCBzZWdtZW50cywgMCk/LlswXTtcbiAgaWYgKG1hdGNoID09PSB2b2lkIDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKG9wdHM/LnBhcmFtcyA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gbWF0Y2g7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBkYXRhOiBtYXRjaC5kYXRhLFxuICAgIHBhcmFtczogbWF0Y2gucGFyYW1zTWFwID8gZ2V0TWF0Y2hQYXJhbXMoc2VnbWVudHMsIG1hdGNoLnBhcmFtc01hcCkgOiB2b2lkIDBcbiAgfTtcbn1cbmZ1bmN0aW9uIF9sb29rdXBUcmVlKGN0eCwgbm9kZSwgbWV0aG9kLCBzZWdtZW50cywgaW5kZXgpIHtcbiAgaWYgKGluZGV4ID09PSBzZWdtZW50cy5sZW5ndGgpIHtcbiAgICBpZiAobm9kZS5tZXRob2RzKSB7XG4gICAgICBjb25zdCBtYXRjaCA9IG5vZGUubWV0aG9kc1ttZXRob2RdIHx8IG5vZGUubWV0aG9kc1tcIlwiXTtcbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChub2RlLnBhcmFtICYmIG5vZGUucGFyYW0ubWV0aG9kcykge1xuICAgICAgY29uc3QgbWF0Y2ggPSBub2RlLnBhcmFtLm1ldGhvZHNbbWV0aG9kXSB8fCBub2RlLnBhcmFtLm1ldGhvZHNbXCJcIl07XG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgY29uc3QgcE1hcCA9IG1hdGNoWzBdLnBhcmFtc01hcDtcbiAgICAgICAgaWYgKHBNYXA/LltwTWFwPy5sZW5ndGggLSAxXT8uWzJdKSB7XG4gICAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChub2RlLndpbGRjYXJkICYmIG5vZGUud2lsZGNhcmQubWV0aG9kcykge1xuICAgICAgY29uc3QgbWF0Y2ggPSBub2RlLndpbGRjYXJkLm1ldGhvZHNbbWV0aG9kXSB8fCBub2RlLndpbGRjYXJkLm1ldGhvZHNbXCJcIl07XG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgY29uc3QgcE1hcCA9IG1hdGNoWzBdLnBhcmFtc01hcDtcbiAgICAgICAgaWYgKHBNYXA/LltwTWFwPy5sZW5ndGggLSAxXT8uWzJdKSB7XG4gICAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgY29uc3Qgc2VnbWVudCA9IHNlZ21lbnRzW2luZGV4XTtcbiAgaWYgKG5vZGUuc3RhdGljKSB7XG4gICAgY29uc3Qgc3RhdGljQ2hpbGQgPSBub2RlLnN0YXRpY1tzZWdtZW50XTtcbiAgICBpZiAoc3RhdGljQ2hpbGQpIHtcbiAgICAgIGNvbnN0IG1hdGNoID0gX2xvb2t1cFRyZWUoY3R4LCBzdGF0aWNDaGlsZCwgbWV0aG9kLCBzZWdtZW50cywgaW5kZXggKyAxKTtcbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChub2RlLnBhcmFtKSB7XG4gICAgY29uc3QgbWF0Y2ggPSBfbG9va3VwVHJlZShjdHgsIG5vZGUucGFyYW0sIG1ldGhvZCwgc2VnbWVudHMsIGluZGV4ICsgMSk7XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfVxuICB9XG4gIGlmIChub2RlLndpbGRjYXJkICYmIG5vZGUud2lsZGNhcmQubWV0aG9kcykge1xuICAgIHJldHVybiBub2RlLndpbGRjYXJkLm1ldGhvZHNbbWV0aG9kXSB8fCBub2RlLndpbGRjYXJkLm1ldGhvZHNbXCJcIl07XG4gIH1cbiAgcmV0dXJuO1xufVxuXG5mdW5jdGlvbiByZW1vdmVSb3V0ZShjdHgsIG1ldGhvZCwgcGF0aCkge1xuICBjb25zdCBzZWdtZW50cyA9IHNwbGl0UGF0aChwYXRoKTtcbiAgcmV0dXJuIF9yZW1vdmUoY3R4LnJvb3QsIG1ldGhvZCB8fCBcIlwiLCBzZWdtZW50cywgMCk7XG59XG5mdW5jdGlvbiBfcmVtb3ZlKG5vZGUsIG1ldGhvZCwgc2VnbWVudHMsIGluZGV4KSB7XG4gIGlmIChpbmRleCA9PT0gc2VnbWVudHMubGVuZ3RoKSB7XG4gICAgaWYgKG5vZGUubWV0aG9kcyAmJiBtZXRob2QgaW4gbm9kZS5tZXRob2RzKSB7XG4gICAgICBkZWxldGUgbm9kZS5tZXRob2RzW21ldGhvZF07XG4gICAgICBpZiAoT2JqZWN0LmtleXMobm9kZS5tZXRob2RzKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgbm9kZS5tZXRob2RzID0gdm9pZCAwO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qgc2VnbWVudCA9IHNlZ21lbnRzW2luZGV4XTtcbiAgaWYgKHNlZ21lbnQgPT09IFwiKlwiKSB7XG4gICAgaWYgKG5vZGUucGFyYW0pIHtcbiAgICAgIF9yZW1vdmUobm9kZS5wYXJhbSwgbWV0aG9kLCBzZWdtZW50cywgaW5kZXggKyAxKTtcbiAgICAgIGlmIChfaXNFbXB0eU5vZGUobm9kZS5wYXJhbSkpIHtcbiAgICAgICAgbm9kZS5wYXJhbSA9IHZvaWQgMDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChzZWdtZW50ID09PSBcIioqXCIpIHtcbiAgICBpZiAobm9kZS53aWxkY2FyZCkge1xuICAgICAgX3JlbW92ZShub2RlLndpbGRjYXJkLCBtZXRob2QsIHNlZ21lbnRzLCBpbmRleCArIDEpO1xuICAgICAgaWYgKF9pc0VtcHR5Tm9kZShub2RlLndpbGRjYXJkKSkge1xuICAgICAgICBub2RlLndpbGRjYXJkID0gdm9pZCAwO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgY2hpbGROb2RlID0gbm9kZS5zdGF0aWM/LltzZWdtZW50XTtcbiAgaWYgKGNoaWxkTm9kZSkge1xuICAgIF9yZW1vdmUoY2hpbGROb2RlLCBtZXRob2QsIHNlZ21lbnRzLCBpbmRleCArIDEpO1xuICAgIGlmIChfaXNFbXB0eU5vZGUoY2hpbGROb2RlKSkge1xuICAgICAgZGVsZXRlIG5vZGUuc3RhdGljW3NlZ21lbnRdO1xuICAgICAgaWYgKE9iamVjdC5rZXlzKG5vZGUuc3RhdGljKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgbm9kZS5zdGF0aWMgPSB2b2lkIDA7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBfaXNFbXB0eU5vZGUobm9kZSkge1xuICByZXR1cm4gbm9kZS5tZXRob2RzID09PSB2b2lkIDAgJiYgbm9kZS5zdGF0aWMgPT09IHZvaWQgMCAmJiBub2RlLnBhcmFtID09PSB2b2lkIDAgJiYgbm9kZS53aWxkY2FyZCA9PT0gdm9pZCAwO1xufVxuXG5mdW5jdGlvbiBmaW5kQWxsUm91dGVzKGN0eCwgbWV0aG9kID0gXCJcIiwgcGF0aCwgb3B0cykge1xuICBpZiAocGF0aFtwYXRoLmxlbmd0aCAtIDFdID09PSBcIi9cIikge1xuICAgIHBhdGggPSBwYXRoLnNsaWNlKDAsIC0xKTtcbiAgfVxuICBjb25zdCBzZWdtZW50cyA9IHNwbGl0UGF0aChwYXRoKTtcbiAgY29uc3QgbWF0Y2hlcyA9IF9maW5kQWxsKGN0eCwgY3R4LnJvb3QsIG1ldGhvZCwgc2VnbWVudHMsIDApO1xuICBpZiAob3B0cz8ucGFyYW1zID09PSBmYWxzZSkge1xuICAgIHJldHVybiBtYXRjaGVzO1xuICB9XG4gIHJldHVybiBtYXRjaGVzLm1hcCgobSkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBkYXRhOiBtLmRhdGEsXG4gICAgICBwYXJhbXM6IG0ucGFyYW1zTWFwID8gZ2V0TWF0Y2hQYXJhbXMoc2VnbWVudHMsIG0ucGFyYW1zTWFwKSA6IHZvaWQgMFxuICAgIH07XG4gIH0pO1xufVxuZnVuY3Rpb24gX2ZpbmRBbGwoY3R4LCBub2RlLCBtZXRob2QsIHNlZ21lbnRzLCBpbmRleCwgbWF0Y2hlcyA9IFtdKSB7XG4gIGNvbnN0IHNlZ21lbnQgPSBzZWdtZW50c1tpbmRleF07XG4gIGlmIChub2RlLndpbGRjYXJkICYmIG5vZGUud2lsZGNhcmQubWV0aG9kcykge1xuICAgIGNvbnN0IG1hdGNoID0gbm9kZS53aWxkY2FyZC5tZXRob2RzW21ldGhvZF0gfHwgbm9kZS53aWxkY2FyZC5tZXRob2RzW1wiXCJdO1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgbWF0Y2hlcy5wdXNoKC4uLm1hdGNoKTtcbiAgICB9XG4gIH1cbiAgaWYgKG5vZGUucGFyYW0pIHtcbiAgICBfZmluZEFsbChjdHgsIG5vZGUucGFyYW0sIG1ldGhvZCwgc2VnbWVudHMsIGluZGV4ICsgMSwgbWF0Y2hlcyk7XG4gICAgaWYgKGluZGV4ID09PSBzZWdtZW50cy5sZW5ndGggJiYgbm9kZS5wYXJhbS5tZXRob2RzKSB7XG4gICAgICBjb25zdCBtYXRjaCA9IG5vZGUucGFyYW0ubWV0aG9kc1ttZXRob2RdIHx8IG5vZGUucGFyYW0ubWV0aG9kc1tcIlwiXTtcbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICBtYXRjaGVzLnB1c2goLi4ubWF0Y2gpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb25zdCBzdGF0aWNDaGlsZCA9IG5vZGUuc3RhdGljPy5bc2VnbWVudF07XG4gIGlmIChzdGF0aWNDaGlsZCkge1xuICAgIF9maW5kQWxsKGN0eCwgc3RhdGljQ2hpbGQsIG1ldGhvZCwgc2VnbWVudHMsIGluZGV4ICsgMSwgbWF0Y2hlcyk7XG4gIH1cbiAgaWYgKGluZGV4ID09PSBzZWdtZW50cy5sZW5ndGggJiYgbm9kZS5tZXRob2RzKSB7XG4gICAgY29uc3QgbWF0Y2ggPSBub2RlLm1ldGhvZHNbbWV0aG9kXSB8fCBub2RlLm1ldGhvZHNbXCJcIl07XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICBtYXRjaGVzLnB1c2goLi4ubWF0Y2gpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbWF0Y2hlcztcbn1cblxuZXhwb3J0IHsgYWRkUm91dGUsIGNyZWF0ZVJvdXRlciwgZmluZEFsbFJvdXRlcywgZmluZFJvdXRlLCByZW1vdmVSb3V0ZSB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/rou3/dist/index.mjs\n");

/***/ })

};
;